### Bitmask (비트마스킹)

# 정수의 이진수 표현 자체를 자료 구조로 활용하는 테크닉
# 어떤 정수를 이진수로 표현할 시 각 자리수(비트)는 무조건 0 혹은 1로 표현된다는 점에 착안하여,
# 그 각 자리수의 0과 1을 특정 상태에 대응시켜 비트 연산을 이용해 문제를 풀어나가는 방식
# 비트마스킹 테크닉을 이용하면 코드의 가독성은 다소 떨어지나 일반적으로 리스트 등을 이용할 때보다
# 메모리 면에서 엄청난 이득을 보고, 비트 연산을 이용하기 때문에 시간 복잡도가 O(1)로 구현되는 연산이 
# 대부분이라 속도 면에서도 이득을 볼 수 있음

### 예시 코드
# 비트마스킹을 이용한 집합 구현

# 최대 10개의 원소(0번째 원소 ~ 9번째 원소)로 구성된 집합
# 각 자리의 비트값이 0이면 해당 자리수의 원소가 집합에 없음, 1이면 있음을 나타냄
# 초기 상태는 모든 비트값을 0으로 초기화하여 공집합으로 설정
bitset = 0b0 

# 만약 집합을 꽉 채우고 싶으면 모든 비트를 1로 설정하면 됨
bitset = 0b1111111111
bitset = (1 << 10) - 1

# k를 입력받아 k번째 원소를 집합에 추가
# 1을 k번 왼쪽으로 비트 시프트하여 OR 연산으로 k번째 자리에 1을 삽입
k = int(input())
bitset = bitset | (1 << k)

# k를 입력받아 k번째 원소를 집합에서 제거
# 1을 k번 왼쪽으로 비트 시프트하여 NOT 연산으로 비트를 모두 뒤집은 뒤(0b0111....111) AND 연산으로
# k번째 원소를 0으로 만듬
# 0 ~ k-1번째 원소에 대해서는 AND 연산을 적용해도 원래의 데이터가 유지됨
k = int(input())
bitset = bitset & ~(1 << k)

# k를 입력받아 k번째 원소가 들어있는지 확인
# 0 ~ k-1번째 원소는 0과 AND 연산으로 전부 0으로 만들고, k번째 비트가 1이면 계산값은 1 << k가 되어
# YES를 출력하고, k번째 비트가 0이면 계산값은 0이 되어 NO를 출력
k = int(input())
if bitset & (1 << k):
    print('YES')
else:
    print('NO')

# k를 입력받아 k번째 원소를 반전시킴 (0이면 1로, 1이면 0으로)
k = int(input())
bitset = bitset ^ (1 << k)

# 두 집합 사이의 연산에 대해서는, 단순히 비트 연산자를 비트마스킹 집합 자체에 적용 가능함
bitset2 = 0b1
bitset | bitset2 # 합집합
bitset & bitset2 # 교집합
bitset & ~(bitset2) # 차집합
bitset ^ bitset2 # 둘 중 한 군데에만 속한 원소

# 집합의 크기를 구하는 함수
def size_bitset(bitset: int):
    if bitset == 0:
        return 0
    return bitset % 2 + size_bitset(bitset // 2)